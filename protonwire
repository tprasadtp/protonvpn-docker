#!/bin/bash
# SPDX-License-Identifier: GPL-3.0
# SPDX-FileCopyrightText: 2023 Prasad Tengse <tprasadtp@users.noreply.github.com>

set -o pipefail

# Minimum bash version checks
if [[ ${BASH_VERSINFO[0]} -lt 4 ]]; then
    printf "protonwire requires Bash version >= 4.2" 1>&2
    exit 1
elif [[ ${BASH_VERSINFO[1]} -eq 4 ]] && [[ ${BASH_VERSINFO[1]} -lt 2 ]]; then
    printf "protonwire requires Bash version >= 4.2" 1>&2
    exit 1
fi

# Handle Signals
trap __cleanup_bg_tasks EXIT
trap __sigterm_handler SIGTERM
trap __sigint_handler SIGINT
trap __sigabrt_handler SIGABRT

function __sigterm_handler() {
    log_warning "Received SIGTERM, exiting..."
    if __protonvpn_disconnect; then
        log_debug "Helathcheck errors - $__PROTONWIRE_HC_ERRORS"
        if [[ $__PROTONWIRE_HC_ERRORS == "0" ]]; then
            exit 0
        fi
    fi
    exit 1
}

function __sigint_handler() {
    log_warning "Received SIGINT, exiting..."
    __protonvpn_disconnect
    exit 1
}

# SIGABRT is not supported on containers
# It will never be trapped as tini or catatonit
# will never forward the signal to the process
# Its here for systemd watchdog compatibility
function __sigabrt_handler() {
    log_warning "Received SIGABRT, exiting..."
    __protonvpn_disconnect
    exit 1
}

function __print_version() {
    local PROTONWIRE_VERSION="dev"
    local PROTONWIRE_COMMIT="HEAD"
    printf "protonwire version %s(%s)\n" "$PROTONWIRE_VERSION" "$PROTONWIRE_COMMIT"
}

#diana::snippet:bashlib-logger:begin#
# shellcheck shell=bash
# shellcheck disable=SC3043

# SHELL LOGGING LIBRARY
# See https://github.com/tprasadtp/shlibs/logger/README.md
# If included in other files, contents between snippet markers
# might automatically be updated (depending on who manages it)
# and all changes between markers might be ignored.

function __is_stderr_colorable() {
    # CLIFORCE is set and CLIFORCE != 0, force colors
    if [[ -n ${CLIFORCE} ]] && [[ ${CLIFORCE} != "0" ]]; then
        return 0

    # CLICOLOR == 0 or NO_COLOR is set and not empty
    # TERM is dumb or linux
    elif [[ -n ${NO_COLOR} ]] ||
        [[ ${CLICOLOR} == "0" ]] ||
        [[ ${TERM} == "dumb" ]] ||
        [[ ${TERM} == "linux" ]]; then
        return 1
    fi

    if [[ -t 2 ]]; then
        return 0
    fi
    return 1
}

function __is_stdout_colorable() {
    # CLIFORCE is set and CLIFORCE != 0, force colors
    if [[ -n ${CLIFORCE} ]] && [[ ${CLIFORCE} != "0" ]]; then
        return 0

    # CLICOLOR == 0 or NO_COLOR is set and not empty
    # TERM is dumb or linux
    elif [[ -n ${NO_COLOR} ]] ||
        [[ ${CLICOLOR} == "0" ]] ||
        [[ ${TERM} == "dumb" ]] ||
        [[ ${TERM} == "linux" ]]; then
        return 1
    fi

    if [[ -t 1 ]]; then
        return 0
    fi
    return 1
}

# Logger core ::internal::
# This function should NOT be called directly.
function __logger_core_event_handler() {
    [[ $# -lt 2 ]] && return 1

    local lvl_caller="${1:-info}"

    # Logging levels are similar to python's logging levels
    case ${lvl_caller} in
    trace)
        level="0"
        ;;
    debug)
        level="10"
        ;;
    info)
        level="20"
        ;;
    success)
        level="20"
        ;;
    notice)
        level="25"
        ;;
    warning)
        level="30"
        ;;
    error)
        level="40"
        ;;
    critical)
        level="50"
        ;;
    *)
        level="100"
        ;;
    esac

    # Immediately return if log level is not enabled
    # If LOG_LVL is not set, defaults to 20 - info level
    if [[ ${LOG_LVL:-20} -gt "${level}" ]]; then
        return
    fi

    shift
    local lvl_msg="$*"

    local lvl_color
    local lvl_colorized
    local lvl_reset

    if __is_stderr_colorable; then
        lvl_colorized="true"
        # shellcheck disable=SC2155
        lvl_reset="\e[0m"
    fi

    # Level name in string format
    local lvl_prefix
    # Level name in string format with timestamp if enabled or level symbol
    local lvl_string
    # Caller trace
    local caller_info

    # Log format
    if [[ ${LOG_FMT:-pretty} == "pretty" ]] && [[ -n ${lvl_colorized} ]]; then
        lvl_string="[â€¢]"
    elif [[ ${LOG_FMT} = "full" ]] || [[ ${LOG_FMT} = "long" ]]; then
        if [[ ${LOG_LVL:-20} -lt 20 ]]; then
            printf -v lvl_prefix "%(%FT%TZ)T (%-4s) " -1 "${BASH_LINENO[1]}"
        else
            printf -v lvl_prefix "%(%FT%TZ)T" -1
        fi
    elif [[ ${LOG_FMT} = "journald" ]] || [[ ${LOG_FMT} = "journal" ]]; then
        if [[ ${LOG_LVL:-20} -lt 20 ]]; then
            printf -v lvl_prefix "(%-4s) " "${BASH_LINENO[1]}"
        fi
    fi

    # Define level, color and timestamp
    # By default we do not show log level and timestamp.
    # However, if LOG_FMT is set to "full" or "long",
    # we will enable long format with timestamps
    case "$lvl_caller" in
    trace)
        # if lvl_string is set earlier, that means LOG_FMT is default or pretty
        # we dont display timestamp or level name in this case. otherwise
        # append level name to lvl_prefix
        # (lvl_prefix is populated with timestamp if LOG_FMT is full or long)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[TRACE   ]"
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;246m"
        ;;
    debug)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[DEBUG   ]"
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;250m"
        ;;
    info)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[INFO    ]"
        # Avoid printing color reset sequence as this level is not colored
        [[ -n "${lvl_colorized}" ]] && lvl_reset=""
        ;;
    success)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[SUCCESS ]"
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;83m"
        ;;
    notice)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[NOTICE  ]"
        # shellcheck disable=SC2155
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;81m"
        ;;
    warning)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[WARNING ]"
        # shellcheck disable=SC2155
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;214m"
        ;;
    error)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[ERROR   ]"
        # shellcheck disable=SC2155
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;197m"
        ;;
    critical)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[CRITICAL]"
        # shellcheck disable=SC2155
        [[ -n "${lvl_colorized}" ]] && lvl_color="\e[38;5;196m"
        ;;
    *)
        [[ -z ${lvl_string} ]] && lvl_string="${lvl_prefix}[UNKNOWN ]"
        # Avoid printing color reset sequence as this level is not colored
        [[ -n "${lvl_colorized}" ]] && lvl_reset=""
        ;;
    esac

    printf "${lvl_color}%s %s ${lvl_reset}\n" "${lvl_string}" "$lvl_msg" 1>&2
}

# Leveled Loggers
function log_trace() {
    __logger_core_event_handler "trace" "$@"
}

function log_debug() {
    __logger_core_event_handler "debug" "$@"
}

function log_info() {
    __logger_core_event_handler "info" "$@"
}

function log_success() {
    __logger_core_event_handler "success" "$@"
}

function log_warning() {
    __logger_core_event_handler "warning" "$@"
}

function log_warn() {
    __logger_core_event_handler "warning" "$@"
}

function log_notice() {
    __logger_core_event_handler "notice" "$@"
}

function log_error() {
    __logger_core_event_handler "error" "$@"
}

function log_critical() {
    __logger_core_event_handler "critical" "$@"
}

function log_variable() {
    local var="$1"
    local __msg_string
    printf -v __msg_string "%-${4:-35}s : %s" "${var}" "${!var:-NA}"
    __logger_core_event_handler "debug" "${__msg_string}"
}

function log_kv_pair() {
    local __msg_string
    printf -v __msg_string "%-${4:-25}s : %s" "${1:-NA}" "${2:-NA}"
    __logger_core_event_handler "debug" "${__msg_string}"
}

# For logging command outputs
# Pipe output of your command to this function
# This is EXPERIMENTAL FEATURE!!
# If used without a pipe causes script to hang!
# - Accepts optional arguments.
#  ARG 1 (str) - msg prefix, this will be prefixed with every line of output
function log_tail() {
    local line prefix
    [[ -n $1 ]] && prefix="($1) "
    while read -r line; do
        __logger_core_event_handler "trace" "$prefix$line"
    done
}
#diana::snippet:bashib-logger:end#

# cleanup background tasks
function __cleanup_bg_tasks() {
    declare -a pending_tasks
    readarray -t pending_tasks < <(jobs -p)
    if [[ ${#pending_tasks[@]} -gt 1 ]]; then
        log_debug "Cleaning up background tasks - ${pending_tasks[*]:-NONE}"
        for pid in "${pending_tasks[@]}"; do
            log_debug "Stopping PID - $pid with SIGTERM"
            if ! kill -s TERM "$pid" >/dev/null 2>&1; then
                log_warning "Failed to stop PID - $pid"
            fi
        done
    fi
}

# Checks if command is available
function has_command() {
    if command -v "$1" >/dev/null; then
        return 0
    else
        return 1
    fi
    return 1
}

# Data validation and manipulation
# --------------------------------------------------
function __is_int() {
    if [[ $1 =~ ^[1-9][0-9]+$ ]]; then
        return 0
    fi
    return 1
}

# Validate IPv4 or CIDR.
function __is_valid_ipv4() {
    local IPV4_REGEX="(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))"
    local IPV4_REGEX_SUBNET="([0-9]|[12][0-9]|3[012])"

    local address

    while [[ ${1} != "" ]]; do
        case $1 in
        --cidr | --subnet)
            IPV4_REGEX="${IPV4_REGEX}/${IPV4_REGEX_SUBNET}"
            ;;
        --ip) ;;

        -*)
            log_error "Unknown option: $1"
            return 1
            ;;
        *)
            address="$1"
            ;;
        esac
        shift
    done

    if [[ $address =~ ^$IPV4_REGEX$ ]]; then
        return 0
    fi
    return 1
}

function __is_valid_ipv6() {
    # Yup, its ugly.
    local IPV6_REGEX="(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))"
    local IPV6_REGEX_SUBNET="([0-9]{1,2}|1[01][0-9]|12[0-8])"

    local address

    while [[ ${1} != "" ]]; do
        case $1 in
        --cidr | --subnet)
            IPV6_REGEX="${IPV6_REGEX}/${IPV6_REGEX_SUBNET}"
            ;;
        --ip) ;;

        -*)
            log_error "Unknown option: $1"
            return 1
            ;;
        *)
            address="$1"
            ;;
        esac
        shift
    done

    if [[ $address =~ ^$IPV6_REGEX$ ]]; then
        return 0
    fi
    return 1
}

function __is_valid_ipcheck_url() {
    log_info "Verifying IPCHECK_URL - ${IPCHECK_URL}"

    if [[ -e ${__PROTONWIRE_HCR} ]]; then
        if ! rm -f "${__PROTONWIRE_HCR}" 2>&1 | log_tail "rm ipcheck-response"; then
            log_error "Failed to remove existing IP chck response file - ${__PROTONWIRE_HCR}"
            return 1
        fi
    fi

    case ${IPCHECK_URL} in
    http://*)
        log_error "IPCHECK_URL must be secure (https://)"
        return 1
        ;;
    https://*)
        local curl_rc="-1"
        {
            curl \
                --fail \
                --location \
                --max-time 20 \
                --connect-timeout 30 \
                --silent \
                --show-error \
                --user-agent 'protonwire/v7' \
                --output "${__PROTONWIRE_HCR}" \
                "${IPCHECK_URL}" 2>&1 | log_tail "curl-ipcheck-url" &
        }
        wait $!
        curl_rc="$?"

        if [[ $curl_rc == "0" ]]; then
            declare -a ip_check_response
            readarray -t ip_check_response <"${__PROTONWIRE_HCR}"

            if __is_valid_ipv4 "${ip_check_response[0]}"; then
                log_debug "IP Check endpoint returned ${ip_check_response[0]}(IPv4)"
                return 0
            elif __is_valid_ipv6 "${ip_check_response[0]}"; then
                log_debug "IP Check endpoint returned ${ip_check_response[0]}(IPv6)"
                return 0
            else
                log_error "IP Check endpoint returned invalid IP address(${entry_ips[0]})"
                return 1
            fi
        elif [[ $curl_rc == 6 ]]; then
            log_error "Failed to validate ipcheck endpoint ${IPCHECK_URL} (dns error)"
            return 1
        elif [[ $curl_rc == 28 ]]; then
            log_error "Failed to validate ipcheck endpoint ${IPCHECK_URL} (timeout)"
            return 1
        else
            log_error "Failed to validate ipcheck endpoint ${IPCHECK_URL} (curl exit code: ${curl_rc})"
            return 1
        fi
        ;;
    *)
        log_error "Invalid IPCHECK_URL - $IPCHECK_URL"
        return 1
        ;;
    esac
    return 1
}

# checks if IPv6 is enabled on the system
function __is_ipv6_disabled() {
    if [[ $(sysctl -n net.ipv6.conf.all.disable_ipv6) == "1" ]]; then
        return 0
    elif [[ $(sysctl -n net.ipv6.conf.default.disable_ipv6) == "1" ]]; then
        return 0
    fi
    return 1
}

# Check if DEBUG is set
function __is_debug() {
    case "${DEBUG,,}" in
    true | yes | enable | enabled | on | 1)
        return 0
        ;;
    esac
    return 1
}

# Check if DNS configuration is disbaled
function __is_skip_cfg_dns() {
    if [[ ${__PROTONWIRE_DNS_UPDATER,,} == "none" ]]; then
        return 0
    fi

    case ${SKIP_DNS,,} in
    yes | true | enable | enabled | on | 1)
        return 0
        ;;
    esac

    return 1
}

# Check if killswitch is enabled
function __is_enable_killswitch() {
    case ${KILLSWITCH,,} in
    yes | true | enable | enabled | on | 1)
        return 0
        ;;
    esac
    return 1
}

# Checks if NOTIFY_SOCKET is defined and valid
function __has_notify_socket() {
    if [[ -n $NOTIFY_SOCKET ]]; then
        if [[ -S ${NOTIFY_SOCKET} ]]; then
            return 0
        else
            log_warning "Notify socket '${NOTIFY_SOCKET}' is not a socket!"
        fi
    fi
    return 1
}

# Wrapper for systemd-notify
function __systemd_notify() {
    local status
    local status_prefix
    local status_lock=0

    while [[ ${1} != "" ]]; do
        case ${1} in
        --ready | -r | ready)
            status_prefix="READY="
            status="1"
            ;;
        --stopping)
            status_prefix="STOPPING="
            status="1"
            ;;
        --reloading)
            status_prefix="RELOADING="
            status="1"
            ;;
        --status | -s | status)
            shift
            status_prefix="STATUS="
            status="$1"
            ;;
        --watchdog | -w)
            status_prefix="WATCHDOG="
            status="1"
            ;;
        *)
            if [[ $1 =~ ^(STATUS|WATCHDOG|READY|STOPPING|RELOADING)=(.*) ]]; then
                status="$1"
            else
                log_error "sd-notify - Invalid status type/message ${1}"
                return 1
            fi
            ;;
        esac
        shift
    done

    # check if status message is defined
    if [[ -z $status ]]; then
        log_error "Status is not defined or empty!"
        return 1
    fi

    if has_command systemd-notify; then
        if timeout 2s \
            systemd-notify "${status_prefix}${status}" 2>&1 | log_tail "systemd-notify"; then
            return 0
        else
            log_debug "systemd-notify failed to send status ${status}"
        fi
    elif has_command nc; then
        if printf "%s%s" "${status_prefix}" "${status}" |
            timeout 2s nc -w 0 -uU "$NOTIFY_SOCKET" 2>&1 | log_tail "nc-notify"; then
            return 0
        else
            log_debug "nc failed to send status ${status}"
        fi
    else
        log_error "Neither systemd-notify nor nc is available!"
    fi
    return 1
}

# systemd-resolved supports default routes in >= 241
function __check_systemd_version() {
    local systemd_version="0"
    if has_command systemctl; then
        declare -a systemctl_version_output
        # systemtl --version usually gives, something like:
        # systemd 248 (248.3-1ubuntu8.2)
        # +PAM +AUDIT +SELINUX ..... <snip>
        # So we need to extract the version number in first line
        readarray -t systemctl_version_output < <(systemctl --version 2>/dev/null)
        if [[ ${#systemctl_version_output[@]} -gt 0 ]]; then
            if [[ ${systemctl_version_output[0]} =~ ^systemd[[:space:]]+([0-9]+)[[:space:]]+\(.*\)$ ]]; then
                systemd_version="${BASH_REMATCH[1]}"
            else
                log_error "systemctl --version did not match expected format"
                return 1
            fi
        else
            log_warning "systemctl --version did not return any output!"
            return 1
        fi
    else
        log_error "systemd is not available"
        return 1
    fi

    if [[ $systemd_version =~ ^[0-9]+$ ]]; then
        log_debug "systemd version - $systemd_version"
        if [[ $systemd_version -ge 242 ]]; then
            return 0
        else
            log_error "systemd version is too old ($systemd_version), please upgrade to systemd 241 or later"
        fi
    else
        log_error "systemd version is invalid ($systemd_version)"
    fi
    return 1
}

# sd-notify and watchdog checks
function __sd_notify_checks() {
    local errs=0
    local sd_socket_check="false"

    # sd-watchdog checks
    if [[ ${WATCHDOG_USEC} =~ ^[1-9][0-9]+$ ]]; then
        local ping_interval
        ping_interval="$((WATCHDOG_USEC / 2000000))"
        if [[ $ping_interval -lt 10 ]]; then
            log_error "Watchdog ping interval is too low($ping_interval) should be at least 10 secs"
            ((++errs))
        else
            log_debug "Watchdog ping interval is $ping_interval secs"
        fi
    else
        log_debug "WATCHDOG_USEC is not set or invalid"
    fi

    if [[ -n $NOTIFY_SOCKET ]]; then
        if [[ -S $NOTIFY_SOCKET ]]; then
            log_debug "NOTIFY_SOCKET is set to $NOTIFY_SOCKET"
            if ! __systemd_notify --status "Initializing"; then
                log_error "sd_notify socket is not working!"
                ((++errs))
            fi
        else
            log_warning "NOTIFY_SOCKET is set but not a socket"
        fi
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

# detect dns update handler
function __detect_dns_updater() {
    if [[ -n $__PROTONWIRE_DNS_UPDATER ]]; then
        return 0
    fi

    if ! __is_skip_cfg_dns; then
        if has_command systemctl; then
            if systemctl is-active --quiet systemd-resolved; then
                if [[ -L /etc/resolv.conf ]]; then
                    log_debug "Using systemd-resolved for DNS"
                    __PROTONWIRE_DNS_UPDATER="systemd-resolved"
                else
                    log_debug "Using resolvconf(8) for DNS (/etc/resolv.conf is not a symlink)"
                    __PROTONWIRE_DNS_UPDATER="resolvconf"
                fi
            else
                log_debug "Using resolvconf(8) for DNS (systemd-resolved is not running)"
                __PROTONWIRE_DNS_UPDATER="resolvconf"
            fi
        else
            log_debug "Using resolvconf(8) for DNS (systemd is not available)"
            __PROTONWIRE_DNS_UPDATER="resolvconf"
        fi
    else
        log_debug "Skipping DNS configuration"
        __PROTONWIRE_DNS_UPDATER="none"
    fi
}

# checks capabilities
function __check_caps() {
    if capsh --has-p=CAP_NET_ADMIN >/dev/null 2>&1; then
        log_debug "Can use CAP_NET_ADMIN capability"
        return 0
    else
        log_error "CAP_NET_ADMIN capability is not available!"
        log_error "If running as systemd unit ensure 'AmbientCapabilities' is set to 'CAP_NET_ADMIN'"
        log_error "If running as podman/docker use --cap-add=CAP_NET_ADMIN flag."
        log_error "Otherwise, run as root and/or add CAP_NET_ADMIN capability"
    fi
    return 1
}

# systemd and sd-notify checks
function __check_systemd() {
    local errs=0

    # check systemd requirements
    # Triggered by using
    # - systemd-resolved or
    # - running as a systemd unit
    if [[ $__PROTONWIRE_LOOPER == "systemd" ]] ||
        [[ $__PROTONWIRE_DNS_UPDATER == "systemd-resolved" ]]; then
        if ! __check_systemd_version; then
            return 1
        fi
    fi

    # If running as loop via --systemd or --container
    # then check if NOTIFY_SOCKET is set
    if [[ $__PROTONWIRE_LOOPER == "systemd" ]]; then
        if ! __sd_notify_checks; then
            ((++errs))
        fi
    elif [[ $__PROTONWIRE_LOOPER == "container" ]]; then
        if ! __sd_notify_checks; then
            ((++errs))
        fi

        # containers cannot change sysctls so check it now
        if [[ $(sysctl -n net.ipv4.conf.all.rp_filter) != "2" ]] &&
            [[ $(sysctl -n net.ipv4.conf.all.src_valid_mark) != "1" ]]; then
            log_error "net.ipv4.conf.all.rp_filter!=2 && net.ipv4.conf.all.src_valid_mark!=1"
            ((++errs))
            log_error "Set one of the sysctls to expected value,"
            log_error "If using docker/podman add --sysctl net.ipv4.conf.all.rp_filter=2 flag to your run command"
            log_error "If using docker-compose add 'net.ipv4.conf.all.rp_filter: 2' under 'sysctls' section for protonvpn service."
            log_error "If using Kubernetes see https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ to set sysctl values."
        fi
    fi

    # If check systemd variables
    if [[ $__PROTONWIRE_LOOPER == "systemd" ]]; then
        declare -ar systemd_populated_vars=(
            "RUNTIME_DIRECTORY"
            "STATE_DIRECTORY"
            "CACHE_DIRECTORY"
            "LOGS_DIRECTORY"
        )

        for var in "${systemd_populated_vars[@]}"; do
            if [[ -z ${!var} ]]; then
                log_warning "$var is not defined!"
            else
                log_variable "$var"
            fi
        done
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

# Checks all commands are available
function __check_tools() {
    local errs=0

    log_debug "Checking requirements"
    declare -a commands=(
        "curl"    # curl
        "jq"      # jq
        "ip"      # iproute2
        "capsh"   # libcap/libcap2-bin (pulled by iproute2)
        "timeout" # coreutils
        "wg"      # wireguard-tools | wireguard-tools-wg
        "sysctl"  # procps
        # "flock"   # flock | linux-utils
    )

    # Detect how to update DNS and add required commands to list of commands to check
    __detect_dns_updater

    case ${__PROTONWIRE_DNS_UPDATER,,} in
    systemd-resolved)
        commands+=(
            "resolvectl" # systemd
        )
        ;;
    resolvconf)
        commands+=(
            "resolvconf" # resolvconf | openresolv
        )
        # Check if resolvconf can update /etc/resolv.conf
        if [[ ! -w /etc/resolv.conf ]]; then
            log_error "Cannot update DNS, /etc/resolv.conf is not writable"
            ((++errs))
        fi
        ;;
    none) ;;
    *)
        log_error "Unknown __PROTONWIRE_DNS_UPDATER - ${__PROTONWIRE_DNS_UPDATER:-NA}"
        ((++errs))
        ;;
    esac

    # systemctl is required for checking systemd version,
    # and systemd-resolved status.
    if [[ ${__PROTONWIRE_LOOPER,,} == "systemd" ]] ||
        [[ $__PROTONWIRE_DNS_UPDATER == "systemd-resolved" ]]; then
        commands+=(
            "systemctl" # systemd
        )
    fi

    # Check if all commands are available
    declare -a missing_commands
    for command in "${commands[@]}"; do
        if ! has_command "$command"; then
            ((++errs))
            missing_commands+=("$command")
        fi
    done

    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        log_error "Following commands are missing - ${missing_commands[*]}"
        ((++errs))
    fi

    if [[ $errs -gt 0 ]]; then
        return 1
    fi
}

# check dependencies
function __run_checks() {
    local errs=0

    # Check if all required commands are available
    if ! __check_tools; then
        return 1
    fi

    __detect_paths

    if ! __check_systemd; then
        ((++errs))
    fi

    # check if any interfaces have reserved ip addresses
    declare -a ip_on_ifaces
    readarray -t ip_on_ifaces < <(ip -4 --json addr show | jq -r '.[] | select(.ifname!="protonwire0") | .addr_info[] | .local' 2>/dev/null)
    if [[ ${#ip_on_ifaces[@]} -lt 1 ]]; then
        log_error "There are no interfaces with IP addresses"
        ((++errs))
    else
        for iface_ip in ${ip_on_ifaces[@]}; do
            log_debug "Checking if IP on other interface is reserved - $iface_ip"
            if [[ $iface_ip == "10.2.0.1" ]]; then
                log_error "One of the interfaces has IP - 10.2.0.1, which is reserved for server"
                ((++errs))
            fi
            if [[ $iface_ip == "10.2.0.2" ]]; then
                log_error "One of the interfaces has IP - 10.2.0.2, which is reserved for client"
                ((++errs))
            fi
        done
    fi

    if [[ $IPCHECK_URL != "https://protonwire-api.vercel.app/v1/client/ip" ]]; then
        if ! __is_valid_ipcheck_url; then
            ((++errs))
        fi
    else
        log_notice "Skipped validating default IPCHECK_URL"
    fi

    if ! __check_caps; then
        ((++errs))
    fi

    # If IPCHECK_INTERVAL is defined, and it's not0,
    # then ensure that WATCHDOG_USEC is not defined
    if [[ -n $IPCHECK_INTERVAL ]] &&
        [[ $IPCHECK_INTERVAL != "0" ]] &&
        [[ ${WATCHDOG_USEC} =~ ^[1-9][0-9]+$ ]]; then
        log_error "IPCHECK_INTERVAL(${IPCHECK_INTERVAL}) cannot be used with systemd watchdog WATCHDOG_USEC(${WATCHDOG_USEC})"
        ((++errs))
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

# resolvectl wrapper
function __resolvctl_up_hook() {
    local errs=0

    # Configure search/routing domains and the
    # default-route before configuring the DNS server
    # as per systemd-resolved documentation recommendation.
    if resolvectl domain protonwire0 "~." 2>&1 | log_tail "resolvectl-domain"; then
        log_success "Set routing domain to ~."
    else
        log_error "Failed to set routing domain to ~."
        ((++errs))
    fi

    if resolvectl default-route protonwire0 "true" 2>&1 | log_tail "resolvectl-default-route"; then
        log_success "Set default route"
    else
        log_error "Failed to set default route"
        ((++errs))
    fi

    if resolvectl dns protonwire0 "10.2.0.1" 2>&1 | log_tail "resolvectl-dns"; then
        log_success "Set DNS server to 10.2.0.1"
    else
        log_error "Failed to set DNS server to 10.2.0.1"
        ((++errs))
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    else
        __resolvctl_down_hook # ignore errors
    fi

    return 1
}

function __resolvctl_down_hook() {
    if resolvectl revert protonwire0 2>&1 | log_tail "resolvectl-revert"; then
        log_success "Reverted systemd-resolved configuration for protonwire0"
        return 0
    else
        log_error "Failed to revert systemd-resolved configuration for protonwire0"
        return 1
    fi
}

# resolvconf hook
function __resolvconf_up_hook() {
    local errs=0
    if has_command resolvconf; then
        if printf "nameserver 10.2.0.1" | timeout 5s resolvconf -a protonwire0.wg 2>&1 | log_tail "resolvconf set"; then
            log_debug "Successfully updated /etc/resolv.conf"
        else
            log_error "Failed to update /etc/resolv.conf!"
            ((++errs))
        fi
    else
        log_error "resolvconf is not installed!"
        ((++errs))
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

function __resolvconf_down_hook() {
    if has_command resolvconf; then
        if timeout 5s resolvconf -f -d protonwire0.wg 2>&1 | log_tail "resolvconf restore"; then
            log_debug "Successfully restored /etc/resolv.conf"
            return 0
        else
            log_error "Failed to restore /etc/resolv.conf"
        fi
    else
        log_error "resolvconf is not installed!"
    fi
    return 1
}

function __detect_paths() {
    local runtime_dir

    log_variable "RUNTIME_DIRECTORY"
    log_variable "XDG_RUNTIME_DIR"

    # Runtime files (should be ideally tmpfs)
    if [[ -z $RUNTIME_DIRECTORY ]]; then
        if [[ -n $XDG_RUNTIME_DIR ]]; then
            if [[ -d "$XDG_RUNTIME_DIR" ]] && [[ -w "${XDG_RUNTIME_DIR}" ]]; then
                runtime_dir="$XDG_RUNTIME_DIR"
                if [[ -z ${cache_dir} ]]; then
                    cache_dir="${XDG_RUNTIME_DIR}"
                fi
            else
                log_warning "XDG_RUNTIME_DIR(${XDG_RUNTIME_DIR}) is not a directory or not writable!"
            fi
        fi
    else
        if [[ -d $RUNTIME_DIRECTORY ]] && [[ -w $RUNTIME_DIRECTORY ]]; then
            runtime_dir="${RUNTIME_DIRECTORY}"
            if [[ -z ${cache_dir} ]]; then
                cache_dir="${RUNTIME_DIRECTORY}"
            fi
        else
            log_warning "RUNTIME_DIRECTORY($RUNTIME_DIRECTORY) is not a directory or not writable!"
        fi
    fi

    # fallback to tmp
    if [[ -z ${runtime_dir} ]]; then
        runtime_dir="/tmp"
    fi

    declare -g __PROTONWIRE_SRV_INFO_FILE="${runtime_dir%/}/protonwire.server.json"
    declare -g __PROTONWIRE_HCR="${runtime_dir%/}/protonwire.hc.response"
    log_variable "__PROTONWIRE_SRV_INFO_FILE"
    log_variable "__PROTONWIRE_HCR"
}

# connect command
function protonvpn_looper_cmd() {
    case "$__PROTONWIRE_LOOPER" in
    systemd)
        log_debug "Running as systemd unit, IDENTITY=$(id)"
        ;;
    container)
        log_debug "Running as container"
        ;;
    *)
        log_error "Invalid __PROTONWIRE_LOOPER - $__PROTONWIRE_LOOPER"
        return 1
        ;;
    esac

    if ! __run_checks; then
        log_error "Please fix the errors above and try again!"
        return 1
    fi

    log_variable "PROTONVPN_CHECK_THRESHOLD"
    log_variable "IPCHECK_INTERVAL"

    if __protonvpn_connect; then
        if [[ $IPCHECK_INTERVAL != "0" ]]; then
            log_info "Verifying connection"

            local verify_attemps=0
            local max_verify_attemps="${PROTONVPN_CHECK_THRESHOLD:-3}"
            while [[ $verify_attemps -lt $max_verify_attemps ]]; do
                ((++verify_attemps))
                if __protonvpn_verify_connection; then
                    log_success "Connection verified!"
                    break
                else
                    log_error "Retry ($verify_attemps/$max_verify_attemps) after 2 seconds"
                    sleep 2 &
                    wait $!
                fi
            done

            if [[ $verify_attemps -ge $max_verify_attemps ]]; then
                log_error "Failed to verify connection!"
                __protonvpn_disconnect
                return 1
            fi
        else
            log_warning "Not verifying connection, as healthchecks are disabled"
        fi
    else
        log_error "Failed to connect to ${PROTONVPN_SERVER}"
        if [[ -z $(ip link show protonwire0 type wireguard 2>/dev/null) ]]; then
            log_debug "Wireguard interface for protonwire is not present."
            return 1
        fi
        __protonvpn_disconnect
        return 1
    fi

    local sleep_int=60
    local watchdog_pings="false"

    # detect ping interval
    if [[ -n $IPCHECK_INTERVAL ]]; then
        if [[ $IPCHECK_INTERVAL == "0" ]] &&
            [[ ${WATCHDOG_USEC} =~ ^[1-9][0-9]+$ ]]; then
            sleep_int="$((WATCHDOG_USEC / 2000000))"
            log_debug "Watchdog enabled, ping interval $sleep_int seconds"
            watchdog_pings="true"
        elif [[ $IPCHECK_INTERVAL != "0" ]]; then
            sleep_int="$IPCHECK_INTERVAL"
        fi
    else
        if [[ ${WATCHDOG_USEC} =~ ^[1-9][0-9]+$ ]]; then
            sleep_int="$((WATCHDOG_USEC / 2000000))"
            log_debug "Watchdog enabled, ping interval $sleep_int seconds"
            watchdog_pings="true"
        fi
    fi

    # Notify ready if socket is available
    if __has_notify_socket; then
        log_debug "Notifying systemd that we are ready"
        if ! __systemd_notify --ready; then
            log_error "Failed to notify systemd!"
            __protonvpn_disconnect
            return 1
        fi

        if ! __systemd_notify --watchdog; then
            log_error "Failed to notify systemd!"
            __protonvpn_disconnect
            return 1
        fi
    else
        log_debug "No systemd notify socket found, skiping READY notification"
    fi

    if [[ $IPCHECK_INTERVAL == "0" ]]; then
        log_warning "Healthchecks are disabled"
        log_info "Listening for signals"
        __PROTONWIRE_HC_ERRORS=0
        while :; do
            if [[ $__PROTONWIRE_DISCONNECTING == "true" ]]; then
                log_debug "Disconnect handler is active, exiting loop"
                break
            fi

            if [[ $watchdog_pings == "true" ]]; then
                if __has_notify_socket; then
                    if ! __systemd_notify --watchdog; then
                        log_error "Failed to notify systemd watchdog!"
                    fi
                fi
            fi

            sleep "${sleep_int:-60}" &
            wait $!
        done
    else
        log_info "Checking status - every ${sleep_int:-60} seconds"

        declare -g __PROTONWIRE_HC_ERRORS=0
        while :; do
            if [[ $__PROTONWIRE_DISCONNECTING == "true" ]]; then
                log_debug "Disconnect handler is active, exiting loop"
                break
            fi

            if [[ $__PROTONWIRE_HC_ERRORS -ge ${PROTONVPN_CHECK_THRESHOLD:-3} ]]; then
                log_error "Connection verification #{$__PROTONWIRE_CHECK_ERRS} failed"
                break
            fi

            sleep "${sleep_int:-60}" &
            wait $!

            if ! __protonvpn_verify_connection; then
                log_error "Failed to verify connection ($((__PROTONWIRE_HC_ERRORS + 1))/${PROTONVPN_CHECK_THRESHOLD:-3})"
                ((++__PROTONWIRE_HC_ERRORS))
            else
                if [[ $__PROTONWIRE_HC_ERRORS -gt 0 ]]; then
                    log_warning "Connection re-established"
                    __PROTONWIRE_HC_ERRORS=0
                fi

                if [[ $watchdog_pings == "true" ]]; then
                    if __has_notify_socket; then
                        if ! __systemd_notify --watchdog; then
                            log_error "Failed to notify systemd watchdog!"
                        fi
                    else
                        log_warning "NOTIFY_SOCKET is missing!"
                    fi
                fi
            fi
        done
    fi
    return 1
}

# when running as a service, script periodically refreshes the metadata.
function protonvpn_fetch_metadata() {
    local metadata_stale="true"
    local force_refresh="${PROTONVPN_FORCE:-false}"
    local wrapped_invocation="false"

    while [[ ${1} != "" ]]; do
        case ${1} in
        --force-refresh | --force | -f)
            force_refresh="true"
            ;;
        --wrapper | -w)
            wrapped_invocation="true"
            ;;
        esac
        shift
    done

    # to avoid urlencoding as server names contain '#'
    # replace it with - which is required by metadata API.
    local api_server_name
    api_server_name="${PROTONVPN_SERVER//#/-}"

    # Check if __PROTONWIRE_SRV_INFO_FILE is present and corresponds to correct server.
    if [[ -f ${__PROTONWIRE_SRV_INFO_FILE} ]]; then
        local current_ts=0
        local metadata_ts=-1

        metadata_ts=$(stat -c %Y ${__PROTONWIRE_SRV_INFO_FILE})
        printf -v current_ts '%(%s)T' -1

        if [[ $((current_ts - metadata_ts)) -lt 7200 ]]; then
            metadata_stale="false"
        else
            log_warning "Server info is stale - ${__PROTONWIRE_SRV_INFO_FILE}"
        fi

        # check if existing metadata file belongs to correct server
        local existing_server_name
        local existing_server_dns
        existing_server_name="$(jq -r '.Name' "${__PROTONWIRE_SRV_INFO_FILE}")"
        existing_server_dns="$(jq -r '.DNS' "${__PROTONWIRE_SRV_INFO_FILE}")"

        # If metadata is not stale, check if it belongs to the server.
        if [[ $metadata_stale == "false" ]]; then
            if [[ $existing_server_name == "$PROTONVPN_SERVER" ]] ||
                [[ $existing_server_dns == "$PROTONVPN_SERVER" ]] ||
                [[ ${existing_server_name//#/-} == "$api_server_name" ]]; then
                log_debug "Existing metadata is valid"
            else
                log_info "Existing metadata($existing_server_name/$existing_server_dns) does not belong to ${PROTONVPN_SERVER}"
                metadata_stale="true"
            fi
        fi
    else
        log_debug "Server info file is missing - ${__PROTONWIRE_SRV_INFO_FILE}"
    fi

    # Fetch if file is stale or forced
    if [[ $metadata_stale != "false" ]] || [[ $force_refresh == "true" ]]; then
        log_info "Refresing server metadata (for $PROTONVPN_SERVER)"
        local api_call="${SERVER_METADATA_URL}/${api_server_name}"
        log_debug "API - ${api_call}"
        local curl_rc="-1"
        # we use wait to ensure the term signals can be handled properly
        { curl \
            --fail \
            --location \
            --max-time 30 \
            --connect-timeout 20 \
            --silent \
            --show-error \
            --user-agent 'protonwire/v7' \
            --output "${__PROTONWIRE_SRV_INFO_FILE}.bak" \
            "${api_call}" 2>&1 | log_tail "curl" & }
        wait $!
        curl_rc="$?"

        # save to a backup file as download can fail or be corrupted
        if [[ $curl_rc == "0" ]]; then
            # ensure file is json formatted and valid
            if jq --exit-status '.Nodes' "${__PROTONWIRE_SRV_INFO_FILE}.bak" >/dev/null 2>&1; then
                if mv "${__PROTONWIRE_SRV_INFO_FILE}.bak" "${__PROTONWIRE_SRV_INFO_FILE}"; then
                    log_success "Successfully refreshed server metadata"
                else
                    log_error "Refreshing server metadata failed (trampoline error)"
                    return 1
                fi
            else
                log_error "Refreshing server metadata failed (invalid json)"
                return 1
            fi
        elif [[ $hc_response_rc == 6 ]]; then
            log_error "Failed to refresh ProtonVPN server metadata (failed to resolve domain)"
            return 1
        elif [[ $hc_response_rc == 28 ]]; then
            log_error "Failed to refresh ProtonVPN server metadata (timeout)"
            return 1
        elif [[ $hc_response_rc == 32 ]]; then
            log_error "Failed to refresh ProtonVPN server metadata (flock timeout/conflict)"
            return 1
        else
            log_error "Failed to refresh ProtonVPN server metadata (curl exit code: ${curl_rc})"
            return 1
        fi
    else
        if [[ $wrapped_invocation == "true" ]]; then
            log_debug "Server metadata is already upto date"
        else
            log_success "Server metadata is already upto date"
        fi
    fi

    # Load entire JSON to memory
    local __json_tmp
    __json_tmp="$(<"${__PROTONWIRE_SRV_INFO_FILE}")"
    # ensure loaded json is parsable
    if jq --exit-status '.Nodes' <<<"$__json_tmp" >/dev/null 2>&1; then
        log_debug "__PROTONWIRE_SRV_INFO_FILE JSON valid"
        # we update the json here to avoid cases where json on disk might be invalid
        # this is unlikely but has happened due to nfs mount issues.
        declare -g __PROTONWIRE_SRV_INFO="$__json_tmp"
        return 0
    else
        log_error "__PROTONWIRE_SRV_INFO_FILE JSON is invalid"
    fi

    return 1
}

# Healthcheck via status file age
function protonvpn_healthcheck_status_file() {
    if [[ $IPCHECK_INTERVAL == "0" ]]; then
        log_error "Healthchecks are disabled, cannot use status file!"
        return 1
    fi

    __detect_paths

    if [[ -n $IPCHECK_INTERVAL ]] &&
        [[ ${WATCHDOG_USEC} =~ ^[1-9][0-9]+$ ]]; then
        log_error "IPCHECK_INTERVAL(${IPCHECK_INTERVAL}) cannot be used with systemd watchdog WATCHDOG_USEC(${WATCHDOG_USEC})"
        return 1
    fi

    log_debug "Checking via file timestamp (${__PROTONWIRE_HCR})"

    if [[ -z $IPCHECK_INTERVAL ]] &&
        [[ ${WATCHDOG_USEC} =~ ^[1-9][0-9]+$ ]]; then
        local check_interval="$((WATCHDOG_USEC / 2000000))"
    elif [[ -n $IPCHECK_INTERVAL ]]; then
        local check_interval="$IPCHECK_INTERVAL"
    else
        log_debug "No healthcheck interval defined, using default(60)"
        local check_interval="60"
    fi

    if [[ -f ${__PROTONWIRE_HCR} ]]; then
        local hc_time
        hc_time="$(stat -c '%Y' "${__PROTONWIRE_HCR}")"

        local current_ts
        printf -v current_ts '%(%s)T' -1

        local hc_diff="-1"
        hc_diff=$((current_ts - hc_time))

        if [[ $hc_diff -lt $((check_interval + 30)) ]]; then
            log_success "Healthcheck is up (via status file), last checked ${hc_diff}s ago"
            return 0
        else
            log_error "Healthcheck is down (via status file), last checked ${hc_diff}s ago"
            return 1
        fi
    else
        log_error "Healthcheck response file (${__PROTONWIRE_HCR}) does not exist!"
        log_error "Perhaps Healthchecks are disabled?"
        return 1
    fi
}

# verify connected server
function __protonvpn_verify_connection() {
    if [[ -z ${__PROTONWIRE_SRV_INFO} ]]; then
        declare -g __PROTONWIRE_SRV_INFO="$(<"$__PROTONWIRE_SRV_INFO_FILE")"
    fi

    if [[ -z ${__PROTONWIRE_SRV_INFO} ]]; then
        log_error "__PROTONWIRE_SRV_INFO is undefined!"
        return 1
    fi

    # check if has wireguard interface
    if [[ -z $(ip link show protonwire0 type wireguard 2>/dev/null) ]]; then
        log_error "WireGuard interface - protonwire0 is not present"
        return 1
    else
        log_debug "WireGuard interface - protonwire0 is present"
    fi

    # check if connected to a server
    declare -a configured_endpoints
    readarray -t configured_endpoints < <(wg show protonwire0 peers 2>/dev/null)
    if [[ ${#configured_endpoints[@]} -eq 0 ]]; then
        log_error "WireGuard interface 'protonwire0' is not connected to any peers"
        return 1
    elif [[ ${#configured_endpoints[@]} -gt 1 ]]; then
        log_debug "Connected peers - ${configured_endpoints[*]}"
        log_error "WireGuard interface 'protonwire0' is connected to multiple peers(${#configured_endpoints[@]})"
        return 1
    else
        log_debug "Connected to peer - ${configured_endpoints[*]}"
    fi

    # verify if server is correct.
    local node_name
    local node_dns
    declare -a expected_endpoints
    declare -a allowed_exit_ips

    node_name="$(jq -r --arg peer "${configured_endpoints[0]}" 'select(.Nodes[].PublicKey==$peer) | .Name' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
    node_dns="$(jq -r --arg peer "${configured_endpoints[0]}" 'select(.Nodes[].PublicKey==$peer) | .DNS' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"

    if [[ -n $PROTONVPN_SERVER ]]; then
        if [[ ${PROTONVPN_SERVER^^} == "${node_name^^}" ]] ||
            [[ ${PROTONVPN_SERVER^^//#/-} == "${node_name^^}" ]] ||
            [[ ${PROTONVPN_SERVER,,} == "${node_dns,,}" ]]; then
            log_debug "Connected to server: ${node_name:-NA}(${node_dns:-NA})"
            # server attributes are only validated if flags are specified
            if ! __protonvpn_verify_server_attributes; then
                return 1
            fi
        else
            log_error "Expected to be connected to server $PROTONVPN_SERVER, but is connected to ${node_name:-NA}(${node_dns:-NA})"
            return 1
        fi
    else
        log_debug "PROTONVPN_SERVER is not specified, only validating exit IPs"
    fi

    readarray -t allowed_exit_ips < <(jq -r ".ExitIPs[]" <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)
    log_debug "Allowed ExitIPs  - ${allowed_exit_ips[*]}"

    # check if array not empty!
    if [[ ${#allowed_exit_ips[@]} -eq 0 ]] &&
        [[ ${#allowed_entry_ips[@]} -eq 1 ]]; then
        log_error "Failed to parse allowed ExitIPs from - ${__PROTONWIRE_SRV_INFO_FILE}"
        return 1
    fi

    local hc_response
    local hc_response_with_status
    local hc_response_code
    local hc_response_rc=-1

    # Invoke healthcheck API and save response
    log_debug "Checking client IP via $IPCHECK_URL"
    {
        curl \
            --max-time 20 \
            --silent \
            --output "${__PROTONWIRE_HCR}" \
            --fail \
            --location \
            --user-agent "protonwire/v7" \
            "$IPCHECK_URL" 2>/dev/null &
    }
    wait $!
    hc_response_rc="$?"
    log_debug "Healthcheck curl exit code - ${hc_response_rc:-NA}"

    local ts_format
    printf -v ts_format '%(%I:%M:%S %p)T' -1

    if [[ $hc_response_rc == 6 ]]; then
        log_error "Failed to resolve DNS domain ($IPCHECK_URL)"
        return 1
    elif [[ $hc_response_rc == 28 ]]; then
        log_error "curl failed to connect to $$IPCHECK_URL (timeout)"
        return 1

    elif [[ $hc_response_rc != 0 ]]; then
        log_error "curl command exited with $hc_response_rc (HTTP response code ${hc_response_code:-NA})"
        return 1
    fi

    local client_ip
    client_ip="$(<"$__PROTONWIRE_HCR")"
    log_debug "Client IP address - $client_ip"

    if [[ -z $client_ip ]]; then
        log_error "Failed to get client IP from - ${__PROTONWIRE_HCR}"
        return 1
    fi

    for exit_ip in "${allowed_exit_ips[@]}"; do
        if [[ $exit_ip == "${client_ip}" ]]; then
            if __has_notify_socket; then
                log_debug "Connected to ${node_dns} (via $client_ip)"
                if ! __systemd_notify --status "Connected to ${node_dns} (via $client_ip), verified at $ts_format UTC"; then
                    log_error "Failed to notify status to systemd"
                fi
            else
                log_success "Connected to ${node_dns:-NA} (via $client_ip)"
            fi
            return 0
        fi
    done
    log_error "Your current IP address - ${client_ip} is not in the list for server ${node_dns:-NA}"
    log_error "Your current IP address - ${client_ip} must belong to set (${allowed_exit_ips[*]})"

    if __has_notify_socket; then
        if ! __systemd_notify --status "ExitIP mismatch for server ${node_dns:-NA} (via $client_ip)"; then
            log_error "Failed to notify error status to systemd"
        fi
    fi

    return 20
}

# healthcheck
function protonvpn_verify_cmd() {
    __detect_paths

    if ! __check_tools; then
        return 1
    fi

    if ! __check_caps; then
        return 1
    fi

    local verify_rc=-1
    __protonvpn_verify_connection
    verify_rc="$?"
    if [[ $verify_rc -eq 0 ]]; then
        return 0
    elif [[ $verify_rc -eq 20 ]]; then
        return 20
    fi
    return 1

}

# checks if keyfile is usuable
# Verifies - input is a file
#          - follow symlinks
#          - file is readable
#          - file is not empty
#          - file has correct permissions (660 or better)
#          - file is a valid key
function __is_usable_keyfile() {
    local file_path="$1"

    if [[ -z ${file_path} ]]; then
        log_error "__is_usable_keyfile() requires a file path"
        return 1
    fi

    if [[ -L ${file_path} ]]; then
        log_debug "File - ${file_path} is a symbolic link following it"
        file_path="$(readlink -f "${file_path}")"
    fi

    if [[ -f $file_path ]]; then
        if [[ -r $file_path ]] && [[ -s $file_path ]]; then
            local fp_perms="stat-error"
            fp_perms="$(stat -c '%a' "${file_path}")"
            case $fp_perms in
            400 | 600 | 440 | 640 | 660)
                log_debug "File - ${file_path} has correct permissions (${fp_perms})"
                return 0
                ;;
            *)
                log_warning "File - $file_path has insecure permissions ($fp_perms)"
                return 1
                ;;
            esac
        else
            log_warning "$file_path is not readable or empty!"
        fi
    else
        log_warning "$file_path is not a file!"
    fi
    return 1
}

# Builds list of routable subnets
function __build_subnets() {
    local errs
    if [[ -z $PROTONVPN_ALLOWED_SUBNETS_IPV4 ]]; then
        log_debug "Excluding RFC-1918 subnets(IPv4) except DNS sever from WireGuard table"
        declare -ga __PROTONWIRE_SUBNET_4=(
            "10.2.0.1/32" # DNS server
            "0.0.0.0/5"
            "8.0.0.0/7"
            "11.0.0.0/8"
            "12.0.0.0/6"
            "16.0.0.0/4"
            "32.0.0.0/3"
            "64.0.0.0/3"
            "96.0.0.0/6"
            "100.0.0.0/10"
            "100.128.0.0/9"
            "101.0.0.0/8"
            "102.0.0.0/7"
            "104.0.0.0/5"
            "112.0.0.0/5"
            "120.0.0.0/6"
            "124.0.0.0/7"
            "126.0.0.0/8"
            "128.0.0.0/3"
            "160.0.0.0/5"
            "168.0.0.0/8"
            "169.0.0.0/9"
            "169.128.0.0/10"
            "169.192.0.0/11"
            "169.224.0.0/12"
            "169.240.0.0/13"
            "169.248.0.0/14"
            "169.252.0.0/15"
            "169.255.0.0/16"
            "170.0.0.0/7"
            "172.0.0.0/12"
            "172.32.0.0/11"
            "172.64.0.0/10"
            "172.128.0.0/9"
            "173.0.0.0/8"
            "174.0.0.0/7"
            "176.0.0.0/4"
            "192.0.0.0/9"
            "192.128.0.0/11"
            "192.160.0.0/13"
            "192.169.0.0/16"
            "192.170.0.0/15"
            "192.172.0.0/14"
            "192.176.0.0/12"
            "192.192.0.0/10"
            "193.0.0.0/8"
            "194.0.0.0/7"
            "196.0.0.0/6"
            "200.0.0.0/5"
            "208.0.0.0/4"
            "224.0.1.0/24"
            "224.0.2.0/23"
            "224.0.4.0/22"
            "224.0.8.0/21"
            "224.0.16.0/20"
            "224.0.32.0/19"
            "224.0.64.0/18"
            "224.0.128.0/17"
            "224.1.0.0/16"
            "224.2.0.0/15"
            "224.4.0.0/14"
            "224.8.0.0/13"
            "224.16.0.0/12"
            "224.32.0.0/11"
            "224.64.0.0/10"
            "224.128.0.0/9"
            "225.0.0.0/8"
            "226.0.0.0/7"
            "228.0.0.0/6"
            "232.0.0.0/5"
        )
        declare -a invalid_ipv4_routes=()
    else
        log_debug "ALLOWED_SUBNETS_IPV4 - ${PROTONVPN_ALLOWED_SUBNETS_IPV4}"
        declare -a invalid_ipv4_routes=()
        # shellcheck disable=SC2206
        declare -ga __PROTONWIRE_SUBNET_4=(${PROTONVPN_ALLOWED_SUBNETS_IPV4//,/ })
        if [[ ${#__PROTONWIRE_SUBNET_4[@]} -eq 0 ]]; then
            log_error "No allowed IPv4 routes specified"
            ((++errs))
        else
            for ipv4_route in "${__PROTONWIRE_SUBNET_4[@]}"; do
                if ! __is_valid_ipv4 --subnet "$ipv4_route"; then
                    ((++errs))
                    invalid_ipv4_routes+=("$ipv4_route")
                fi
            done
        fi
    fi

    if [[ -z $PROTONVPN_ALLOWED_SUBNETS_IPV6 ]]; then
        log_debug "Excluding ULA subnets(IPv6) from WireGuard table"
        declare -ga __PROTONWIRE_SUBNET_6=("2000::/3")
        declare -a invalid_ipv6_routes=()
    else
        log_debug "ALLOWED_SUBNETS_IPV6 - ${PROTONVPN_ALLOWED_SUBNETS_IPV6}"
        declare -a __PROTONWIRE_SUBNET_6=()
        declare -a invalid_ipv6_routes=()
        # shellcheck disable=SC2206
        declare -ga __PROTONWIRE_SUBNET_6=(${PROTONVPN_ALLOWED_SUBNETS_IPV6//,/ })
        if [[ ${#__PROTONWIRE_SUBNET_6[@]} -eq 0 ]]; then
            log_error "No allowed IPv6 routes specified"
            ((++errs))
        else
            for ipv6_route in "${__PROTONWIRE_SUBNET_6[@]}"; do
                if ! __is_valid_ipv6 --subnet "$ipv6_route"; then
                    ((++errs))
                    invalid_ipv6_routes+=("$ipv6_route")
                fi
            done
        fi
    fi

    if [[ ${#invalid_ipv4_routes[@]} -gt 0 ]]; then
        log_error "Invalid IPv4 routes specified: ${invalid_ipv4_routes[*]}"
        ((++errs))
    fi

    if [[ ${#invalid_ipv6_routes[@]} -gt 0 ]]; then
        log_error "Invalid IPv6 routes specified: ${invalid_ipv6_routes[*]}"
        ((++errs))
    fi

    if [[ $errs -gt 0 ]]; then
        return 1
    fi
}

# Build route table
function __build_route_table() {
    local table_type="$1"
    declare -a table_action

    case "${table_type}" in
    wireguard)
        table_id="51821"
        table_action=(dev protonwire0)
        ;;
    killswitch)
        table_id="51822"
        table_action=(prohibit)
        ;;
    *)
        log_error "Unknown route table type: $table_type"
        return 1
        ;;
    esac

    if __is_ipv6_disabled; then
        declare -ar __rt_protos=("4")
    else
        declare -ar __rt_protos=("4" "6")
    fi

    local errs=0
    for proto in "${__rt_protos[@]}"; do
        if [[ $proto == "4" ]]; then
            declare -a desired_routes=("${__PROTONWIRE_SUBNET_4[@]}")
        elif [[ $proto == "6" ]]; then
            declare -a desired_routes=("${__PROTONWIRE_SUBNET_6[@]}")
        fi

        # These bools are false by default as it makes things
        # easier when tracking individual routes easier.
        local create_table="false"
        local flush_table="false"
        log_info "Configuring $table_type table $table_id (IPv$proto)"
        if [[ -z $(ip "-${proto}" route show table "$table_id" 2>/dev/null) ]]; then
            log_debug "Not found $table_type table $table_id (IPv$proto)"
            create_table="true"
        else
            log_debug "Checking routes $table_type table $table_id (IPv$proto)"
            local existing_routes

            log_debug "Collecting routes from $table_type table $table_id (IPv$proto)"
            existing_routes="$(ip "-${proto}" --json route show table "$table_id" | jq -r '.[].dst' 2>/dev/null)"

            if [[ -z ${existing_routes} ]]; then
                log_warning "No routes in $table_type table $table_id (IPv$proto)"
                create_table="true"
            fi

            # we have a route table already, check if its configured correctly
            log_info "Verifying $table_type table $table_id (IPv$proto)"

            for route in "${desired_routes[@]}"; do
                # special handling of /32 route
                __route_regex="(${route}|${route///32/})"

                if [[ "$existing_routes" =~ ${__route_regex} ]]; then
                    log_debug "Route - $route already present in $table_type table $table_id (IPv$proto)"
                else
                    log_warning "Route - $route is not present in $table_type table $table_id (IPv$proto)"
                    create_table="true"
                    flush_table="true"
                fi
            done
        fi

        if [[ $flush_table == "true" ]]; then
            log_debug "Flush (IPv$proto)  table($table_id)"
            if ! ip "-${proto}" route flush table "$table_id" 2>&1 | log_tail "ip route flush"; then
                log_error "Failed to flush $table_type table $table_id (IPv$proto)"
                ((++errs))
            fi
        else
            log_debug "No need to flush $table_type table $table_id (IPv$proto)"
        fi

        if [[ $create_table == "true" ]]; then
            for route in "${desired_routes[@]}"; do
                if ! ip "-${proto}" route add table "$table_id" ${table_action[@]} "$route" 2>&1 | log_tail "ip route"; then
                    log_error "Failed to add $table_type route(IPv$proto) - $route to table($table_id)"
                    ((++errs))
                else
                    log_debug "Added $table_type route(IPv$proto) - $route to table($table_id)"
                fi
            done
        fi
    done

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

# Build route rules.
function __build_route_rules() {
    if __is_ipv6_disabled; then
        declare -ar __rt_protos=("4")
    else
        declare -ar __rt_protos=("4" "6")
    fi

    local errs=0
    for proto in "${__rt_protos[@]}"; do
        declare -a _routes_json
        declare -a wg_rule_p
        declare -a ks_route_p
        declare -a manual_route_p

        readarray -t _routes_json < <(ip "-${proto}" --json rule)
        _routes_json=$(ip "-${proto}" --json rule)

        local config_rules="true"
        log_info "Configuring IP rules (IPv$proto)"
        readarray -t wg_rule_p < <(jq '.[] | select((.fwmark=="0xca6d") and (.table=="51821") and (.src=="all")) | .priority' <<<"${_routes_json}" 2>/dev/null)
        readarray -t ks_route_p < <(jq '.[] | select((.fwmark=="0xca6d") and (.table=="51822") and (.src=="all")) | .priority' <<<"${_routes_json}" 2>/dev/null)
        readarray -t manual_route_p < <(jq '.[] | select((.suppress_prefixlen=0) and (.table=="main") and (.src=="all")) | .priority' <<<"${_routes_json}" 2>/dev/null)

        log_debug "Rule Wiregurad  Table - ${wg_rule_p[*]}"
        log_debug "Rule Killswitch Table - ${wg_rule_p[*]}"
        log_debug "Rule Manual Route     - ${manual_route_p[*]}"

        if [[ ${#wg_rule_p[@]} -eq 1 ]] && [[ ${#ks_route_p[@]} -eq 1 ]]; then
            # wireguard route must have lower priority number than killswitch.
            if [[ ${wg_rule_p[0]} -lt ${ks_route_p[0]} ]]; then
                log_success "IP routing rules are already configured IP(v$proto)"
                config_rules="false"
            else
                log_error "IP routing rules are configured but have wrong priority!"
            fi
        else
            log_debug "wg rules(${#manual_route_p[@]}) and ks rules (${#ks_route_p[@]}), reconfigure rules"
        fi

        if [[ $config_rules != "false" ]]; then
            log_debug "Cleanup old rules if any (IPv$proto)"

            while [[ $(ip "-${proto}" rule show 2>/dev/null) == *"lookup 51821"* ]]; do
                log_warning "Removing WireGuard table rule (IPv$proto)"
                if ! ip "-${proto}" rule del not fwmark 51821 table 51821 2>&1 | log_tail "ip rule"; then
                    log_error "Failed to remove rule(IPv$proto) to route traffic via WireGuard"
                    ((++errs))
                fi
            done

            # from all not fwmark 51821 lookup 51821
            log_debug "Adding IP rule for Wireguard Table (51821)"
            if ! ip "-${proto}" rule add not fwmark 51821 table 51821 2>&1 | log_tail "ip rule"; then
                log_error "Failed to add rule to route traffic via WireGuard(51821)"
                ((++errs))
            fi
        fi
    done

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

# This is protonvpn_fetch_metadata with retries
# This is used in connect command.
function __fetch_metadata_with_retries() {
    local metadata_fetch_tries=0
    local metadata_fetch_max_tries=3
    while [[ $metadata_fetch_tries -lt $metadata_fetch_max_tries ]]; do
        ((++metadata_fetch_tries))
        if protonvpn_fetch_metadata --wrapper; then
            break
        else
            if [[ $metadata_fetch_tries -lt $metadata_fetch_max_tries ]]; then
                log_error "Retrying after $((2 ** metadata_fetch_tries)) seconds ($metadata_fetch_tries/$metadata_fetch_max_tries)"
                sleep "$((2 ** metadata_fetch_tries))" &
                wait $!
            fi
        fi
    done

    # Use cached file if failed to fetch metadata,
    # this is most likely due to a network issue
    log_debug "metadata_fetch_tries=${metadata_fetch_tries}"
    log_debug "metadata_fetch_max_tries=${metadata_fetch_max_tries}"
    if [[ $metadata_fetch_tries -ge $metadata_fetch_max_tries ]]; then
        if [[ ! -f ${__PROTONWIRE_SRV_INFO_FILE} ]]; then
            log_error "Failed to fetch server metadata after $metadata_fetch_max_tries tries!"
            log_error "Please check your internet connection and try again!"
            log_error "If you have killswitch enabled please disable it and try again!"
            return 1
        else
            log_warning "Failed to fetch server metadata after ${metadata_fetch_max_tries} tries, using cached file (might be stale)"
        fi
    fi
}

# Get Wireguard endpoint IPs and public keys
# This also verifies server is online.
function __protonvpn_pre_connect_get_endpoints_and_keys() {
    # Ensure __PROTONWIRE_SRV_INFO is defined
    if [[ -z ${__PROTONWIRE_SRV_INFO} ]]; then
        log_error "__PROTONWIRE_SRV_INFO is undefined!"
        return 1
    fi

    # Check if server is offline
    local _server_online
    _server_online="$(jq -r '.Status' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
    if [[ $_server_online == "ONLINE" ]]; then
        log_success "Server ${PROTONVPN_SERVER} is online"
    else
        log_error "Server ${PROTONVPN_SERVER} is ${_server_online:-UNKNOWN_STATE}!"
        return 1
    fi

    # Extract Endpoint IPs (including offline ones)
    declare -a -g __PROTONWIRE_ENDPOINT_IPS_ALL
    # Extract Endpoint IPs (only online ones)
    declare -a -g __PROTONWIRE_ENDPOINT_IPS_ONLINE

    # Get all Endpoint IPs which are online.
    log_debug "Selecting all ONLINE endpoints"
    readarray -t __PROTONWIRE_ENDPOINT_IPS_ONLINE < <(jq -r \
        '[.Nodes[] | select(.Status=="ONLINE")] | sort_by(.Endpoint) | .[].Endpoint' \
        <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)

    # check if we have atleast one online endpoint server
    # this should not happen as the entire logical node itself should be offline
    # but we include it here to avoid any bugs in API.
    if [[ ${#__PROTONWIRE_ENDPOINT_IPS_ONLINE[@]} -lt 1 ]]; then
        log_error "No online endpoints found for - PROTONVPN_SERVER=${PROTONVPN_SERVER}"
        return 1
    else
        log_variable "__PROTONWIRE_ENDPOINT_IPS_ONLINE"
    fi

    # Get all Endpoint IPs (including offline)
    log_debug "Selecting all endpoints for building keymap"
    readarray -t __PROTONWIRE_ENDPOINT_IPS_ALL < <(jq -r \
        '[.Nodes[]] | sort_by(.Endpoint) | .[].Endpoint' \
        <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)

    # Check if we have atleast endpoint server
    if [[ ${#__PROTONWIRE_ENDPOINT_IPS_ALL[@]} -lt 1 ]]; then
        log_error "No endpoints found for - PROTONVPN_SERVER=${PROTONVPN_SERVER}"
        return 1
    else
        log_variable "__PROTONWIRE_ENDPOINT_IPS_ALL"
    fi

    # Associative array to map endpoint ip to keys.
    declare -A -g __PROTONWIRE_KEY_MAP

    # Loop over all __PROTONWIRE_ENDPOINT_IPS_ALL and get their public key.
    # and save it in an associative array mapping endpoint to public keys.
    # we also consider all nodes as they may not be actually "offline"
    # though non-online nodes are not considered while connecting, only for verification.
    # (Yet another quirk of ProtonVPN API which metadata API cannot fix)
    for endpoint in ${__PROTONWIRE_ENDPOINT_IPS_ALL[@]}; do
        declare -a endpoint_keys
        readarray -t endpoint_keys < <(jq -r \
            --arg endpoint "$endpoint" \
            '[.Nodes[] | select(.Endpoint==$endpoint)] | .[].PublicKey' \
            <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)
        if [[ ${#endpoint_keys[@]} -gt 1 ]]; then
            log_warning "Endpoint($endpoint) has multiple pub keys, only using first key"
            __PROTONWIRE_KEY_MAP["$endpoint"]="${endpoint_keys[0]}"
        elif [[ ${#endpoint_keys[@]} -eq 1 ]]; then
            log_debug "Endpoint($endpoint) has pubkey - ${endpoint_keys[0]}"
            __PROTONWIRE_KEY_MAP["$endpoint"]="${endpoint_keys[0]}"
        else
            log_error "Endpoint($endpoint) for server ${PROTONVPN_SERVER} returned no pubkeys"
            return 1
        fi
    done

    # Collect all exit IPs
    local err=0
    readarray -t __PROTONVPN_EXIT_IP_LIST < <(jq -r \
        '.ExitIPs[]' \
        <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)
    if [[ ${#__PROTONVPN_EXIT_IP_LIST[@]} -lt 1 ]]; then
        log_error "No exit ips found for ${PROTONVPN_SERVER}"
        return 1
    fi

    # As metadata API endpoint is customizable,
    # Verify all returned IP addresseses are valid.
    for _server_exit_ip in ${__PROTONVPN_EXIT_IP_LIST[@]}; do
        if __is_valid_ipv4 "${_server_exit_ip}"; then
            log_debug "Valid Exit IP for ${PROTONVPN_SERVER} - ${_server_exit_ip}(IPv4)"
        elif __is_valid_ipv6 "${ip_check_response[0]}"; then
            log_debug "Valid Exit IP for ${PROTONVPN_SERVER} - ${_server_exit_ip}(IPv6)"
            return 0
        else
            log_error "Metadata endpoint returned invalid exit IP address($_server_exit_ip)"
            ((++err))
        fi
    done

    if [[ $err -eq 0 ]]; then
        return 0
    fi

    return 1
}

# verifies server has required features.
function __protonvpn_verify_server_attributes() {
    # Ensure __PROTONWIRE_SRV_INFO is defined
    if [[ -z ${__PROTONWIRE_SRV_INFO} ]]; then
        log_error "__PROTONWIRE_SRV_INFO is undefined!"
        return 1
    fi

    # Validate server attributes
    local errs=0

    local server_country
    local server_feature_p2p
    local server_feature_streaming
    local server_feature_tor
    local server_feature_secure_core

    if [[ -n $__PROTONWIRE_FEATURE_COUNTRY ]]; then
        server_country="$(jq -r '.ExitCountry' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
        if [[ ${server_country^^} != "${__PROTONWIRE_FEATURE_COUNTRY^^}" ]]; then
            log_error "Expects server's ExitCoutry to be ${__PROTONWIRE_FEATURE_COUNTRY}"
            log_error "But Currently selected server(${PROTONVPN_SERVER^^}) is ${server_country^^}"
            ((++errs))
        else
            log_success "Server ExitCountry is ${__PROTONWIRE_FEATURE_COUNTRY}"
        fi
    else
        log_debug "Not validating country"
    fi

    if [[ $__PROTONWIRE_FEATURE_P2P == "true" ]]; then
        server_feature_p2p="$(jq -r '.P2P' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
        if [[ ${server_feature_p2p,,} != "true" ]]; then
            log_error "Selected server(${PROTONVPN_SERVER}) does not supprt P2P"
            ((++errs))
        else
            log_success "Server supports P2P"
        fi
    else
        log_debug "Not validating if server supports P2P"
    fi

    if [[ $__PROTONWIRE_FEATURE_STREAMING == "true" ]]; then
        server_feature_streaming="$(jq -r '.Streaming' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
        if [[ ${server_feature_streaming,,} != "true" ]]; then
            log_error "Selected server(${PROTONVPN_SERVER}) does not supprt Streaming"
            ((++errs))
        else
            log_success "Server supports Streaming"
        fi
    else
        log_debug "Not validating if server supports Stremaing"
    fi

    if [[ $__PROTONWIRE_FEATURE_TOR == "true" ]]; then
        server_feature_tor="$(jq -r '.Tor' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
        if [[ ${server_feature_tor,,} != "true" ]]; then
            log_error "Selected server(${PROTONVPN_SERVER}) does not supprt Tor"
            ((++errs))
        else
            log_success "Server supports Tor"
        fi
    else
        log_debug "Not validating if server supports Tor"
    fi

    if [[ $__PROTONWIRE_FEATURE_SECURE_CORE == "true" ]]; then
        server_feature_secure_core="$(jq -r '.SecureCore' <<<"${__PROTONWIRE_SRV_INFO}" 2>/dev/null)"
        if [[ ${server_feature_secure_core,,} != "true" ]]; then
            log_error "Selected server(${PROTONVPN_SERVER}) does not supprt SecureCore"
            ((++errs))
        else
            log_success "Server supports SecureCore"
        fi
    else
        log_debug "Not validating if server supports SecureCore"
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    fi

    return 1
}

# Connects to ProtonVPN.
function __protonvpn_connect() {
    local errs=0

    if [[ -z ${PROTONVPN_SERVER} ]]; then
        log_error "PROTONVPN_SERVER not specified"
        return 1
    fi

    if __has_notify_socket; then
        __systemd_notify --status "Connecting to ${PROTONVPN_SERVER}"
    fi

    if ! __fetch_metadata_with_retries; then
        return 1
    fi

    if ! __protonvpn_pre_connect_get_endpoints_and_keys; then
        return 1
    fi

    if ! __protonvpn_verify_server_attributes; then
        return 1
    fi

    # Lookup private key
    local wg_client_pubkey
    local WIREGUARD_PRIVATE_KEY_FILE

    if [[ -n $WIREGUARD_PRIVATE_KEY ]]; then
        local __wg_client_pubkey

        # check if WIREGUARD_PRIVATE_KEY is a file
        if [[ -e $WIREGUARD_PRIVATE_KEY ]]; then
            if __is_usable_keyfile "${WIREGUARD_PRIVATE_KEY}"; then
                __wg_client_pubkey=$(wg pubkey <"${WIREGUARD_PRIVATE_KEY}" 2>/dev/null)
                if [[ -n $__wg_client_pubkey ]]; then
                    WIREGUARD_PRIVATE_KEY_FILE="${WIREGUARD_PRIVATE_KEY}"
                    log_success "Using PrivateKeyFile - ${WIREGUARD_PRIVATE_KEY}"
                    wg_client_pubkey="$__wg_client_pubkey"
                else
                    log_error "PrivateKeyFile - $WIREGUARD_PRIVATE_KEY is invalid!"
                    return 1
                fi
            else
                log_error "PrivateKeyFile - $WIREGUARD_PRIVATE_KEY cannot be used!"
                return 1
            fi
        else
            __wg_client_pubkey=$(wg pubkey <<<"${WIREGUARD_PRIVATE_KEY}" 2>/dev/null)
            if [[ -n $__wg_client_pubkey ]]; then
                log_success "WIREGUARD_PRIVATE_KEY(${WIREGUARD_PRIVATE_KEY:0:5}**********) is a valid key"
            else
                log_error "WIREGUARD_PRIVATE_KEY(${WIREGUARD_PRIVATE_KEY:0:5}**********) is not a valid key"
                return 1
            fi
        fi
    else
        log_debug "WIREGUARD_PRIVATE_KEY is not set"

        # Secrets and other variables
        # files in /etc/protonwire always takes precedence
        declare -a lookup_paths=(
            "/etc/protonwire/private-key"
            "/etc/protonwire/protonwire-private-key"
            "/etc/protonwire/wireguard-private-key"
            "/run/secrets/private-key"
            "/run/secrets/protonwire/private-key"
            "/run/secrets/protonwire/protonwire-private-key"
            "/run/secrets/protonwire/wireguard-private-key"
        )

        # CREDENTIALS_DIRECTORY is defined if using systemd-creds
        if [[ -n $CREDENTIALS_DIRECTORY ]]; then
            lookup_paths+=("${CREDENTIALS_DIRECTORY%/}/private-key")
            lookup_paths+=("${CREDENTIALS_DIRECTORY%/}/protonwire-private-key")
            lookup_paths+=("${CREDENTIALS_DIRECTORY%/}/wireguard-private-key")
        fi

        for lookup_path in "${lookup_paths[@]}"; do
            if [[ -f ${lookup_path} ]]; then
                if __is_usable_keyfile "${lookup_path}"; then
                    local __wg_client_pubkey
                    __wg_client_pubkey=$(wg pubkey <"${lookup_path}" 2>/dev/null)
                    if [[ -n $__wg_client_pubkey ]]; then
                        WIREGUARD_PRIVATE_KEY_FILE="${lookup_path}"
                        log_success "Using PrivateKeyFile - $lookup_path"
                        wg_client_pubkey="$__wg_client_pubkey"
                        break
                    else
                        log_error "PrivateKeyFile - $lookup_path is invalid!"
                    fi
                else
                    log_error "PrivateKeyFile - $lookup_path cannot be used!"
                fi
            elif [[ -e ${lookup_path} ]]; then
                log_debug "File not found - ${lookup_path} (path is not a file)"
            else
                log_debug "File not found - ${lookup_path}"
            fi
        done
    fi

    if [[ -z $WIREGUARD_PRIVATE_KEY_FILE ]] && [[ -z $WIREGUARD_PRIVATE_KEY ]]; then
        log_error "No usable private key found!"
        return 1
    fi

    # sysctl checks
    if [[ $(sysctl -n net.ipv4.conf.all.rp_filter) == "2" ]]; then
        log_success "net.ipv4.conf.all.rp_filter is already set to 2"
    elif [[ $(sysctl -n net.ipv4.conf.all.src_valid_mark) == "1" ]]; then
        log_success "net.ipv4.conf.all.src_valid_mark is already set to 1"
    else
        log_info "Setting net.ipv4.conf.all.rp_filter to 2"
        if ! sysctl -w net.ipv4.conf.all.rp_filter=2 2>&1 | log_tail "sysctl-net-rp_filter"; then
            log_error "Failed to set net.ipv4.conf.all.rp_filter to 2"
            return 1
        fi
    fi

    # Wireguard interface
    local wg_existing_ip
    local wg_exiting_prefixlen
    local wg_exiting_mtu
    local wg_existing_link_state
    declare -a configured_endpoints

    if [[ -n $(ip link show protonwire0 type wireguard 2>/dev/null) ]]; then
        log_notice "WireGuard interface 'protonwire0' already exists"
        local _ipjson
        _ipjson=$(ip --json addr show dev protonwire0)
        if [[ -z $_ipjson ]]; then
            log_error "Failed to get link properties for 'protonwire0'"
            return 1
        fi

        wg_existing_ip="$(jq -r '.[].addr_info[] | select(.family=="inet") | .local' <<<"${_ipjson}" 2>/dev/null)"
        wg_exiting_prefixlen="$(jq -r '.[].addr_info[] | select(.family=="inet") | .prefixlen' <<<"${_ipjson}" 2>/dev/null)"
        wg_exiting_mtu="$(jq -r '.[].mtu' <<<"${_ipjson}" 2>/dev/null)"
        wg_existing_link_state="$(jq -r '.[].operstate' <<<"${_ipjson}" 2>/dev/null)"
        readarray -t configured_endpoints < <(wg show protonwire0 endpoints 2>/dev/null)

        log_debug "Current IPAddress  (protonwire0) : $wg_existing_ip"
        log_debug "Current Prefix     (protonwire0) : $wg_exiting_prefixlen"
        log_debug "Current Link MTU   (protonwire0) : $wg_exiting_mtu"
        log_debug "Current Link State (protonwire0) : $wg_existing_link_state"
        log_debug "Current Endpoints  (protonwire0) : ${configured_endpoints[*]}"
    elif [[ -n $(ip link show protonwire0 2>/dev/null) ]]; then
        log_error "Existing interface 'protonwire0' is not a WireGuard interface"
        return 1
    else
        log_notice "Creating WireGuard Interface - protonwire0"
        if ! ip link add protonwire0 type wireguard 2>&1 | log_tail "ip-link"; then
            log_error "WireGuard interface creation failed!"
            log_error "Please install WireGuard. For more info see https://www.wireguard.com/install/"
            return 1
        fi
    fi

    # Protonvpn has static ip same for all clients
    if [[ $wg_existing_ip == "10.2.0.2" ]] && [[ $wg_exiting_prefixlen == "32" ]]; then
        log_success "WireGuard interface already has address - 10.2.0.2/32"
    else
        if [[ -n $wg_existing_ip ]]; then
            log_info "Flushing all exiting addresses on WireGuard Interface"
            if ! ip address flush "protonwire0" 2>&1 | log_tail "ip-addr"; then
                log_error "Failed to flush addresses on WireGuard interface 'protowire0'"
                return 1
            fi
        fi
        log_info "Setting WireGuard interface address - 10.2.0.2"
        if ! ip -4 address add 10.2.0.2/32 dev protonwire0 2>&1 | log_tail "ip-addr"; then
            log_error "Setting address on 'protonwire0' failed!"
            return 1
        fi
    fi

    # MTU
    if [[ $wg_exiting_mtu == "1480" ]]; then
        log_success "WireGuard interface MTU is already set to - 1480"
    else
        log_info "Setting WireGuard interface MTU to 1480"
        if ! ip link set protonwire0 mtu 1480 2>&1 | log_tail "ip-link"; then
            log_error "Setting protonwire0 MTU failed"
            return 1
        fi
    fi

    # Private key
    # check if public key
    if [[ $(wg show protonwire0 public-key) == "${wg_client_pubkey:-none}" ]]; then
        log_success "WireGuard interface already has private key configured"
    else
        if [[ -n $WIREGUARD_PRIVATE_KEY ]]; then
            if printf "%s" "${WIREGUARD_PRIVATE_KEY}" | wg set protonwire0 private-key /dev/stdin 2>&1 | log_tail "wg-set-key"; then
                log_success "Setting WireGuard private key"
            else
                log_error "Setting WireGuard private key failed!"
                return 1
            fi
        elif [[ -n $WIREGUARD_PRIVATE_KEY_FILE ]]; then
            if wg set protonwire0 private-key "${WIREGUARD_PRIVATE_KEY_FILE}" 2>&1 | log_tail "wg-set-key"; then
                log_success "Setting WireGuard private key from $WIREGUARD_PRIVATE_KEY_FILE"
            else
                log_error "Setting WireGuard private key from $WIREGUARD_PRIVATE_KEY_FILE failed!"
                return 1
            fi
        else
            log_error "Private key is not defined or not found!"
            return 1
        fi
    fi

    # peers and endpoints
    # If interface already has a peer,
    # check if its in the available endpoints
    # if yes, continue to use it.
    # if not, select a random endpoint from list of endpoints.
    local selected_endpoint
    local ep_reconfigure="true"
    if [[ ${#configured_endpoints[@]} -eq 0 ]]; then
        log_debug "No configured endpoints on the interface 'protonwire0'"
    elif [[ ${#configured_endpoints[@]} -eq 1 ]]; then
        log_debug "Single peer configured with ${configured_endpoints[0]}"
        # check if configured endpoint is in the list of online endpoints
        if [[ ${configured_endpoints[0]} == *"${__PROTONWIRE_ENDPOINT_IPS_ONLINE[*]}"* ]]; then
            selected_endpoint="${configured_endpoints[0]}"
            ep_reconfigure="false"
        else
            log_warning "WireGuard interface is configured wrong peer - ${configured_endpoints[0]}"
        fi
    else
        log_warning "WireGuard interface 'protonwire0' is connected to multiple peers(${#configured_endpoints[@]})"
    fi

    # select peer
    if [[ $ep_reconfigure == "true" ]]; then
        local selected_endpoint_index
        log_variable "__PROTONWIRE_ENDPOINT_IPS_ONLINE"
        if [[ ${#__PROTONWIRE_ENDPOINT_IPS_ONLINE[@]} -gt 1 ]]; then
            selected_endpoint_index="$(((RANDOM % ${#__PROTONWIRE_ENDPOINT_IPS_ONLINE[@]}) + 1))"
            selected_endpoint="${__PROTONWIRE_ENDPOINT_IPS_ONLINE["${selected_endpoint_index}"]}"
            log_debug "Selected endpoint($selected_endpoint_index) $selected_endpoint"
        elif [[ ${#__PROTONWIRE_ENDPOINT_IPS_ONLINE[@]} -eq 1 ]]; then
            selected_endpoint="${__PROTONWIRE_ENDPOINT_IPS_ONLINE[0]}"
            log_debug "Selected endpoint $selected_endpoint"
        else
            log_error "No endpoints to select"
            return 1
        fi
    fi

    # Cleanup peers on interfaces
    local errs=0
    if [[ $ep_reconfigure != "false" ]]; then
        for stale_peer in "${configured_endpoints[@]}"; do
            if wg set protonwire0 peer "${stale_peer%%	*}" remove 2>&1 | log_tail "wg-peer-remove"; then
                log_warning "Removed peer - $stale_peer"
            else
                log_error "Failed to remove peer - $stale_peer"
                ((++errs))
            fi
        done
    fi

    if [[ $errs -gt 0 ]]; then
        return 1
    fi

    # Configure peers
    if [[ $ep_reconfigure != "false" ]]; then
        local peer_pub_key
        peer_pub_key="${__PROTONWIRE_KEY_MAP["${selected_endpoint}"]}"
        log_debug "Peer public key - $peer_pub_key"

        if wg set protonwire0 peer "$peer_pub_key" \
            allowed-ips 0.0.0.0/0,::/0 \
            endpoint "${selected_endpoint}:51820" \
            persistent-keepalive 25 \
            2>&1 | log_tail "wg-set-peer"; then
            log_debug "WireGuard interface is configured with peer - $peer_pub_key(${selected_endpoint})"
        else
            log_error "Setting WireGuard peer $peer_pub_key(${selected_endpoint}) on interface failed!"
            return 1
        fi
    else
        log_success "WireGuard interface already has peer - ${selected_endpoint%%	*}(${selected_endpoint##*	})"
    fi

    # Check if link is down if so, bring it up
    if [[ $wg_existing_link_state == "DOWN" ]] || [[ -z $wg_existing_link_state ]]; then
        log_info "Bringing WireGuard interface up"
        if ! ip link set protonwire0 up 2>&1 | log_tail "ip-link"; then
            log_error "Bringing WireGuard interface up failed"
            return 1
        fi
    else
        log_success "WireGuard interface is already UP"
    fi

    # fw mark 0xca6d(51821)
    if [[ $(wg show protonwire0 fwmark) == "0xca6d" ]]; then
        log_success "WireGuard interface fwmark is already set to - 0xca6d"
    else
        if wg set protonwire0 fwmark 0xca6d 2>&1 | log_tail "wg-set-fwmark"; then
            log_success "Setting fwmark on WireGuard interface to - 0xca6d"
        else
            log_error "Setting fwmark on WireGuard interface to - 0xca6d failed!"
            return 1
        fi
    fi

    # Route tables
    if ! __build_subnets; then
        return 1
    fi

    if ! __build_route_table "wireguard"; then
        log_error "Failed to build WireGuard table!"
        return 1
    fi

    if __is_enable_killswitch; then
        if ! __build_route_table "killswitch"; then
            log_error "Failed to build killswitch table!"
            return 1
        fi
    else
        log_debug "Killswitch is disabled, delete killswitch table 51822 if present"
        if __is_ipv6_disabled; then
            declare -ar __rt_protos=("4")
        else
            declare -ar __rt_protos=("4" "6")
        fi

        for proto in "${__rt_protos[@]}"; do
            if [[ -n $(ip "-${proto}" route show table 51822 2>/dev/null) ]]; then
                log_warning "Flush killswitch table (51822) (IPv$proto)"
                if ! ip "-${proto}" route flush table 51822 2>&1 | log_tail "ip route flush"; then
                    log_warning "Failed to flush killswitch table 51822 (IPv$proto)"
                fi
            else
                log_debug "Killswitch table 51822 is not present or empty (IPv$proto)"
            fi
        done
    fi

    if ! __build_route_rules; then
        log_error "Failed to configure routing rules!"
        return 1
    fi

    # DNS
    if __is_skip_cfg_dns; then
        log_info "Skipping DNS configuration"
    else
        if [[ $__PROTONWIRE_DNS_UPDATER == "systemd-resolved" ]]; then
            if __resolvctl_up_hook; then
                log_success "Successfully configured DNS (systemd-resolved)"
            else
                log_error "Failed to configure DNS (systemd-resolved)"
                return 1
            fi
        elif [[ $__PROTONWIRE_DNS_UPDATER == "resolvconf" ]]; then
            if __resolvconf_up_hook; then
                log_success "Successfully configured DNS (resolvconf)"
            else
                log_error "Failed to configure DNS (resolvconf)"
                return 1
            fi
        else
            log_error "Unknown DNS updater: $__PROTONWIRE_DNS_UPDATER"
            return 1
        fi
    fi

    if __has_notify_socket; then
        __systemd_notify --status "Connected to ${__PROTONWIRE_SELECTED_SERVER}"
    fi
}

function protonvpn_connect_cmd() {
    if ! __run_checks; then
        log_error "Please fix the errors and try again!"
        return 1
    fi

    if __protonvpn_connect; then
        return 0
    fi
    return 1
}

function __protonvpn_disconnect() {
    # Order in which we do ensures that we dont have
    # broken dns on the machine/container during disconnect.
    # This is prone to dns leakage during this
    # short disconnect window.
    __PROTONWIRE_DISCONNECTING="true"

    local errs=0

    if __has_notify_socket; then
        log_debug "Notify to systemd that vpn is disconnecting"
        __systemd_notify --stopping
    else
        log_debug "No systemd notify socket found, skiping stopping notification"
    fi

    if [[ $__PROTONWIRE_DNS_UPDATER == "systemd-resolved" ]]; then
        if __resolvctl_down_hook; then
            log_success "Successfully restored DNS(systemd-resolved)"
        else
            log_error "Failed to restore DNS"
            ((++errs))
        fi
    elif [[ $__PROTONWIRE_DNS_UPDATER == "resolvconf" ]]; then
        if __resolvconf_down_hook; then
            log_success "Successfully restored DNS(resolvconf)"
        else
            log_error "Failed to restore DNS"
            ((++errs))
        fi
    elif [[ $__PROTONWIRE_DNS_UPDATER == "none" ]]; then
        :
    else
        log_error "Unknown DNS updater: $__PROTONWIRE_DNS_UPDATER"
        ((++errs))
    fi

    local skip_ipv6="false"
    if __is_ipv6_disabled; then
        log_info "IPv6 disabled, skipping IPv6 routes and rules"
        skip_ipv6="true"
    fi

    log_info "Removing IP rules"
    while [[ $(ip -4 rule show 2>/dev/null) == *"lookup 51821"* ]]; do
        if ! ip -4 rule del not fwmark 51821 table 51821 2>&1 | log_tail "ip rule"; then
            log_error "Failed to remove rule(IPv4) to route traffic via WireGuard"
            ((++errs))
        fi
    done

    if [[ $skip_ipv6 != "true" ]]; then
        while [[ $(ip -6 rule show 2>/dev/null) == *"lookup 51821"* ]]; do
            if ! ip -6 rule del not fwmark 51821 table 51821 2>&1 | log_tail "ip rule"; then
                log_error "Failed to remove rule(IPv4) to route traffic via WireGuard"
                ((++errs))
            fi
        done
    fi

    # delete table
    if ip -4 route list table 51821 >/dev/null 2>&1; then
        log_debug "Flushing routing table 51820 (IPv4)"
        if ! ip -4 route flush table 51821 2>&1 | log_tail "ip route"; then
            log_error "Failed to flush table 51820"
            ((++errs))
        fi
    else
        log_warning "Table 51821(IPv4) does not exist"
    fi

    if [[ $skip_ipv6 != "true" ]]; then
        if ip -6 route list table 51821 >/dev/null 2>&1; then
            log_debug "Flushing routing table 51821 (IPv6)"
            if ! ip -6 route flush table 51821 2>&1 | log_tail "ip route"; then
                log_error "Failed to flush table 51820"
                ((++errs))
            fi
        fi
    fi

    if [[ -n $(ip link show protonwire0 type wireguard 2>/dev/null) ]]; then
        log_info "Removing WireGuard interface"
        if ! ip link del protonwire0 2>&1 | log_tail "ip link"; then
            log_error "Failed to remove WireGuard interface"
            ((++errs))
        fi
    else
        log_warning "WireGuard interface 'protonwire0' does not exist"
    fi

    if [[ $errs -eq 0 ]]; then
        return 0
    fi
    return 1
}

function protonvpn_disconnect_cmd() {
    __detect_paths

    # Check if all required commands are available
    if ! __check_tools; then
        return 1
    fi

    if ! __check_caps; then
        log_error "Run as root and/or add CAP_NET_ADMIN capability"
        return 1
    fi

    if __protonvpn_disconnect; then
        return 0
    fi
    return 1
}

function display_usage() {
    if __is_stdout_colorable; then
        local NC=$'\e[0m'
        local BOLD=$'\e[1m'
        local YELLOW=$'\e[38;5;220m'
        local BLUE=$'\e[38;5;159m'
        local CYAN=$'\e[38;5;51m'
        local ORANGE=$'\e[38;5;208m'
        local TEAL=$'\e[38;5;192m'
        local PINK=$'\e[38;5;212m'
        local GRAY=$'\e[38;5;246m'
        local LGRAY=$'\e[38;5;240m'
        local MAGENTA=$'\e[38;5;219m'
    else
        local NC
        local BOLD
        local YELLOW
        local BLUE
        local CYAN
        local ORANGE
        local TEAL
        local PINK
        local GRAY
        local LGRAY
        local MAGENTA
    fi

    cat <<EOF

${BOLD}ProtonVPN WireGuard Client${NC}

${BOLD}${YELLOW}Usage:${NC} protonwire [OPTIONS...]
${BOLD}${YELLOW}or:${NC} protonwire [OPTIONS...] c|connect [SERVER]
${BOLD}${YELLOW}or:${NC} protonwire [OPTIONS...] d|disconnect
${BOLD}${YELLOW}or:${NC} protonwire [OPTIONS...] check
${BOLD}${YELLOW}or:${NC} protonwire [OPTIONS...] help

${BOLD}${CYAN}Options:${NC}
  -k, --private-key [FILE|KEY]  Wireguard private key or
                                file containing private key
      --container               Run as container
                                (Cannot be used with --systemd)
      --systemd                 Run as systemd service
                                (Cannot be used with --container)
      --metadata-endpoint [URL] Server metadata endpoint URL
      --check-interval [INT]    IP check interval in seconds
      --check-endpoint [URL]    IP check endpoint URL
      --skip-dns-config         Skip configuring DNS.
                                (Useful for Kubernetes and Nomad)
      --killswitch              Enable killswitch (Experimental)
      --p2p                     Check if server supports P2P
      --streaming               Check if server supports streaming
      --tor                     Check if server supports Tor
      --secure-core             Check if server supports secure core
  -q, --quiet                   Show only errors
  -v, --verbose,                Show debug logs
  -h, --help                    Display this help and exit
      --version                 Display version and exit

${BOLD}${TEAL}Examples:${NC}
  protonwire connect NL#17      Connect to server NL#17
  protonwire disconnect         Disconnect from current server
  protonwire check              Check if connected to a server

${BOLD}${ORANGE}Files:${NC}
  /etc/protonwire/private-key   WireGuard private key

${BOLD}${MAGENTA}Environment:${NC}
  WIREGUARD_PRIVATE_KEY         WireGuard private key or file
  PROTONVPN_SERVER              ProtonVPN server name
  IPCHECK_INTERVAL              Custom IP check interval in seconds
  SKIP_DNS_CONFIG               Set to '1' to skip configuring DNS
  KILLSWITCH                    Set to '1' to enable killswitch (Experimental)
  DEBUG                         Set to '1' to enable debug logs
EOF
}

function main() {
    # exclusive option locks, these only validate cli args not env vars
    declare -i log_lvl_v_lock=0
    declare -i log_lvl_q_lock=0
    declare -i cmd_lock=0
    declare -i looper_lock=0
    declare -i ip_check_lock=0

    local color_mode="auto"
    local cmd_mode="HELP"
    local hc_status_file="false"

    # Toggle debug flag
    if __is_debug; then
        LOG_LVL="0"
    fi

    while [[ ${1} != "" ]]; do
        case ${1} in
        -h | --help | help)
            cmd_mode="HELP"
            ;;
        --version)
            cmd_mode="VERSION"
            ;;
        --verbose | --debug | -v)
            LOG_LVL="0"
            ((++log_lvl_v_lock))
            ;;
        --quiet | --silent | -q)
            LOG_LVL=40
            ((++log_lvl_q_lock))
            ;;
        --color)
            shift
            mode="${1}"
            ;;
        --metadata-url | --metadata-endpoint)
            shift
            PROTONWIRE_METADATA_URL="$1"
            ;;
        --logfmt | --logformat | --log-fmt | --log-format)
            shift
            LOG_FMT="${1}"
            ;;
        --check-interval | --ipcheck-interval)
            ((++ip_check_lock))
            shift
            IPCHECK_INTERVAL="${1}"
            ;;
        --check-url | --check-endpoint | --ipcheck-url | --ipcheck-endpoint)
            shift
            IPCHECK_URL="${1}"
            ;;
        --skip-dns | --skip-dns-config)
            SKIP_DNS="false"
            ;;
        -k | --key | --private-key)
            shift
            WIREGUARD_PRIVATE_KEY="$1"
            ;;
        --killswitch | --kill-switch | --ks | -ks)
            KILLSWITCH="true"
            ;;
        --p2p)
            __PROTONWIRE_FEATURE_P2P="true"
            ;;
        --streaming)
            __PROTONWIRE_FEATURE_STREAMING="true"
            ;;
        --tor)
            __PROTONWIRE_FEATURE_TOR="true"
            ;;
        --secure-core)
            __PROTONWIRE_FEATURE_SECURE_CORE="true"
            ;;
        # ISO 3166-1 alpha-2
        --cc | --country)
            shift
            __PROTONWIRE_FEATURE_COUNTRY="$1"
            ;;
        --container)
            ((++looper_lock))
            __PROTONWIRE_LOOPER="container"
            ;;
        --systemd)
            ((++looper_lock))
            __PROTONWIRE_LOOPER="systemd"
            ;;
        connect | c)
            ((++cmd_lock))
            cmd_mode="CONNECT"
            ;;
        disconnect | d)
            cmd_mode="DISCONNECT"
            ((++cmd_lock))
            ;;
        check | healthcheck | health-check | status | s | verify)
            cmd_mode="HEALTHCHECK"
            ((++cmd_lock))
            ;;
        *-)
            log_error "Invalid argument - $1. See usage below."
            display_usage
            exit 1
            ;;
        *)
            PROTONVPN_SERVER="$1"
            ;;
        esac
        shift
    done

    local args_errors=0

    case ${color_mode,,} in
    force | always)
        CLIFORCE="1"
        ;;
    never)
        CLICOLOR="0"
        ;;
    auto) ;;
    *)
        log_error "Invalid --color mode specified - ${color_mode}"
        ((++args_errors))
        ;;
    esac

    # check --debug conflicts with --quiet
    if [[ ${log_lvl_q_lock} -gt 0 ]] && [[ ${log_lvl_v_lock} -gt 0 ]]; then
        log_error "Cannot use --debug/-v and --quiet/-q at the same time."
        ((++args_errors))
    fi

    # Loop mode
    if [[ ${looper_lock} -gt 1 ]]; then
        log_error "Cannot use --container and --systemd at the same time."
        ((++args_errors))
    fi

    # Check if more than one command is specified
    if [[ $cmd_lock -gt 1 ]]; then
        log_error "More than one exclusive command specified!"
        ((++args_errors))
    fi

    if [[ ${cmd_mode} == "CONNECT" ]]; then
        if [[ -z $PROTONVPN_SERVER ]]; then
            log_error "PROTONVPN_SERVER is not defined!"
            ((++args_errors))
        else
            log_variable "PROTONVPN_SERVER"
        fi
    fi

    # check if countey code is valid
    if [[ -n $__PROTONWIRE_FEATURE_COUNTRY ]]; then
        if [[ $__PROTONWIRE_FEATURE_COUNTRY =~ ^[a-zA-Z]{2}$ ]]; then
            log_variable "__PROTONWIRE_FEATURE_COUNTRY"
        else
            log_error "Invalid Country code specified - ${__PROTONWIRE_FEATURE_COUNTRY}"
            ((++args_errors))
        fi
    fi

    if [[ $cmd_mode == "HEALTHCHECK" ]] && [[ $__PROTONWIRE_LOOPER == "container" ]]; then
        cmd_mode="HEALTHCHECK_CONTAINER"
    fi

    if [[ $cmd_mode == "CONNECT" ]]; then
        if [[ $__PROTONWIRE_LOOPER == "container" ]] &&
            [[ $__PROTONWIRE_LOOPER == "container" ]]; then
            cmd_mode="LOOPER"
        fi
    fi

    # check if IPCHECK_INTERVAL
    if [[ -n ${IPCHECK_INTERVAL} ]]; then
        log_variable "IPCHECK_INTERVAL"
        if [[ $IPCHECK_INTERVAL =~ ^[0-9]+$ ]]; then
            if [[ ${IPCHECK_INTERVAL} -eq 0 ]]; then
                :
            elif [[ ${IPCHECK_INTERVAL} -lt 10 ]]; then
                log_error "IPCHECK_INTERVAL must be at-least 10s."
                ((++args_errors))
            fi
        else
            log_error "IPCHECK_INTERVAL must be a positive integer."
            ((++args_errors))
        fi
    fi

    if [[ -z ${IPCHECK_URL} ]]; then
        IPCHECK_URL="https://protonwire-api.vercel.app/v1/client/ip"
        log_variable "IPCHECK_URL"
    fi

    if [[ -z ${SERVER_METADATA_URL} ]]; then
        SERVER_METADATA_URL="https://protonwire-api.vercel.app/v1/server"
        log_variable "SERVER_METADATA_URL"
    fi

    if [[ $args_errors -gt 0 ]]; then
        log_error "See protonwire(1) or protonwire --help for more information."
        exit 1
    fi

    # shellcheck disable=SC2119
    case "${cmd_mode^^}" in
    HEALTHCHECK)
        protonvpn_verify_cmd
        exit $?
        ;;
    HEALTHCHECK_CONTAINER)
        protonvpn_healthcheck_status_file
        exit $?
        ;;
    LOOPER)
        protonvpn_looper_cmd
        exit $?
        ;;
    CONNECT)
        protonvpn_connect_cmd
        exit $?
        ;;
    DISCONNECT)
        protonvpn_disconnect_cmd
        exit $?
        ;;
    HELP)
        display_usage
        exit $?
        ;;
    VERSION)
        __print_version
        exit $?
        ;;
    *)
        log_error "Unknown PROTONVPN_EXE_MODE - $cmd_mode"
        exit 10
        ;;
    esac
}

main "$@"
